#pragma once

#include <cmath>

namespace util {

    /**
     * PI with enough precision for future computers :)
     * (and as constexpr and no preprocessor magic)
     */
    constexpr double PI = 3.1415926535897932384626433832795028841971693993751058209749445923;

    /**
     * PI divided by 180
     */
    constexpr double DivPI180 = PI / 180.0;

    /**
     * PI multiplied by 180
     */
    constexpr double Div180PI = 180.0 / PI;

    /**
     * Density of Aluminium in [kg/m^3]
     */
    constexpr double ALUMINIUM_DENSITY = 2698.9;

    /**
     * Calculates the density according to Equation 1.
     * If the density is smaller than 1cm, the density of Aluminium is returned.
     * @param characteristicLength in [m] which correspond to the diameter
     * @return density in [kg/m^3]
     */
    inline double calculateDensity(double characteristicLength) {
        return characteristicLength < 0.01 ? ALUMINIUM_DENSITY : 92.937 * std::pow(characteristicLength, -0.74);
    }

    /**
     * Calculates the circle area for a given characteristic length.
     * @param characteristicLength in [m] which correspond to the diameter
     * @return area in [m^2]
     */
    inline double calculateCircleArea(double characteristicLength) {
        double radius = characteristicLength / 2.0;
        return PI * radius * radius;
    }

    /**
     * Calculates the characteristicLength (= diameter) for a given circle area.
     * @param area in [m^2]
     * @return diameter in [m]
     */
    inline double calculateCharacteristicLength(double area) {
        return 2.0 * sqrt(area / PI);
    }

    /**
    * Calculates the mass according to a characteristicLength assuming the object is a sphere.
    * @param characteristicLength in [m] which correspond to the diameter
    * @return mass in [kg]
    */
    inline double calculateSphereMass(double characteristicLength) {
        double radius = characteristicLength / 2.0;
        return 4.0 / 3.0 * PI * (radius * radius * radius) * calculateDensity(characteristicLength);
    }

    /**
    * Calculates the Characteristic Length assuming the mass is formed like a sphere.
    * @param mass in [kg] of the satellite
    * @return diameter/ characteristic Length in [m]
    */
    inline double calculateCharacteristicLengthFromMass(double mass) {
        return std::pow((6 * mass) / (92.937 * PI), 1 / 2.26);
    }

    /**
     * Transform an y in [0;1] generated by an uniform distribution to an x which follows the
     * properties of a power law distribution.
     * @param x0 - the lower bound for the numbers (corresponds to the minimal L_c)
     * @param x1 - the upper bound (correspond to the maximum of L_c of the two satellites or infinite if
     *              there is no upper bound)
     * @param n - the exponent from the power law distribution, more precisely the exponent of the
     *              probability density function (pdf)
     * @param y - the value from the uniform distribution to transform
     * @return the transformed x following the power law distribution
     */
    inline double transformUniformToPowerLaw(double x0, double x1, double n, double y) {
        double step = (std::pow(x1, n+1) - std::pow(x0, n+1)) * y + std::pow(x0, n+1);
        return std::pow(step, 1/ (n + 1) );
    }

    /**
     * Converts an angle [deg] to [rad]
     * @param angle in [deg]
     * @return angle in [rad]
     */
    inline double degToRad(double angle) {
        return angle * DivPI180;
    }

    /**
     * Converts an angle [rad] to [deg]
     * @param angle in [rad]
     * @return angle in [deg]
     */
    inline double radToDeg(double angle) {
        return angle * Div180PI;
    }

}